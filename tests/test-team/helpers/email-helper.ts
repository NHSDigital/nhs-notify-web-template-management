import { S3Client, GetObjectCommand } from '@aws-sdk/client-s3';
import { Readable } from 'node:stream';
import { S3Helper } from './s3-helper';

async function streamToString(stream: Readable): Promise<string> {
  return await new Promise((resolve, reject) => {
    const chunks: Buffer[] = [];
    stream.on('data', (chunk) => chunks.push(Buffer.from(chunk)));
    stream.on('error', (err) => reject(err));
    stream.on('end', () => resolve(Buffer.concat(chunks).toString('utf8')));
  });
}

export class EmailHelper {
  private readonly s3Client = new S3Client({ region: 'eu-west-2' });

  private readonly testEmailBucketName = process.env.TEST_EMAIL_BUCKET_NAME;

  constructor() {}

  async getEmailForTemplateId(
    prefix: string,
    templateId: string,
    dateCutoff: Date,
    extraTextToSearch: string
  ) {
    const s3Items = await S3Helper.listAll(this.testEmailBucketName, prefix);

    const sortedKeys = S3Helper.filterAndSort(s3Items, dateCutoff);

    // SES does not tell us what the S3 keys are going to be for received emails,
    // so we have to search all recent ones to ensure we get the right one and
    // not one that was generated by a different test
    for (const { Key } of sortedKeys) {
      const getCommand = new GetObjectCommand({
        Bucket: this.testEmailBucketName,
        Key,
      });

      const { Body } = await this.s3Client.send(getCommand);

      if (!Body || !(Body instanceof Readable)) {
        throw new Error('Unexpected response body type');
      }

      const content = await streamToString(Body);

      if (content.includes(templateId) && content.includes(extraTextToSearch)) {
        return content;
      }
    }

    throw new Error('Email not found');
  }
}
